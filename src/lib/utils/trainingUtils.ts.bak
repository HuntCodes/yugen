import { TrainingSession } from '../../types/training';
import { v4 as uuidv4 } from 'uuid';

/**
 * Determine the training phase based on race date and plan start date
 * @param raceDate Optional date of the race (YYYY-MM-DD format)
 * @param currentDate Current date to calculate phase from
 * @param planStartDate Date when the user started their plan
 * @returns The current training phase
 */
export function getTrainingPhase(
  raceDate?: string | null,
  currentDate: Date = new Date(),
  planStartDate?: Date | null
): string {
  // Clone current date to avoid modifying the original
  const today = new Date(currentDate);
  today.setHours(0, 0, 0, 0);

  // If plan start date is not provided, assume it's the same as current date
  const startDate = planStartDate ? new Date(planStartDate) : new Date(today);
  startDate.setHours(0, 0, 0, 0);

  // Calculate time since plan started (in weeks)
  const weeksSincePlanStart = Math.floor((today.getTime() - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000));
  
  // If race date exists and is valid, calculate phase based on race
  if (raceDate && raceDate !== 'None') {
    const raceDay = new Date(raceDate);
    
    // Handle invalid date
    if (isNaN(raceDay.getTime())) {
      return calculateCyclicalPhase(weeksSincePlanStart);
    }
    
    // Calculate days until race
    const daysUntilRace = Math.floor((raceDay.getTime() - today.getTime()) / (24 * 60 * 60 * 1000));
    
    // Check if race is in the next 3 months (90 days)
    if (daysUntilRace <= 90 && daysUntilRace > 0) {
      // Find the Monday of race week
      const raceDayOfWeek = raceDay.getDay(); // 0 = Sunday, 1 = Monday, etc.
      const daysToRaceWeekMonday = raceDayOfWeek === 0 ? -6 : 1 - raceDayOfWeek; // Calculate days to previous Monday
      
      const raceWeekMonday = new Date(raceDay);
      raceWeekMonday.setDate(raceDay.getDate() + daysToRaceWeekMonday);
      raceWeekMonday.setHours(0, 0, 0, 0);
      
      // Find Monday 1 week before race (taper week)
      const taperWeekMonday = new Date(raceWeekMonday);
      taperWeekMonday.setDate(taperWeekMonday.getDate() - 7);
      
      // Find Monday 2 weeks before race (start of peak)
      const peakWeekMonday = new Date(taperWeekMonday);
      peakWeekMonday.setDate(peakWeekMonday.getDate() - 7);
      
      // Determine phase based on these dates
      if (today >= raceWeekMonday) {
        return "Race Week";
      } else if (today >= taperWeekMonday) {
        return "Taper";
      } else if (today >= peakWeekMonday) {
        return "Peak";
      } else if (daysUntilRace <= 7) {
        // Race is very soon but not on a Monday boundary
        return "Race Week";
      } else {
        // We're still in the build phase
        return "Build";
      }
    }
    
    // Race is more than 3 months away (or in the past), use cyclical pattern
    if (daysUntilRace <= 0) {
      // Race is in the past, check if within recovery period (2 weeks after race)
      const daysAfterRace = Math.abs(daysUntilRace);
      if (daysAfterRace <= 14) {
        return "Recovery";
      }
    }
  }
  
  // No race date or race is far away, use cyclical pattern
  return calculateCyclicalPhase(weeksSincePlanStart);
}

/**
 * Calculate training phase in a cyclical pattern of 3 weeks build + 1 week recovery
 * @param weeksSincePlanStart Number of weeks since the plan started
 * @returns The current training phase
 */
export function calculateCyclicalPhase(weeksSincePlanStart: number): string {
  // First week is always Base
  if (weeksSincePlanStart === 0) {
    return "Base";
  }
  
  // 3 weeks build + 1 week recovery cycle (after the first Base week)
  const adjustedWeeks = weeksSincePlanStart - 1;
  const cyclePosition = adjustedWeeks % 4;
  
  // Weeks 1-3 of cycle are build, week 4 is recovery
  return cyclePosition < 3 ? "Build" : "Recovery";
}

/**
 * Extract the numeric training frequency from the training frequency text
 */
export function extractTrainingFrequency(trainingFrequency: string): number {
  // Try to extract a number from the string
  const matches = trainingFrequency.match(/(\d+)/);
  if (matches && matches[1]) {
    const frequency = parseInt(matches[1], 10);
    // Sanity check - only accept 1-7 days per week
    if (frequency >= 1 && frequency <= 7) {
      return frequency;
    }
  }
  
  // If we couldn't extract a number, try to interpret common phrases
  const loweredText = trainingFrequency.toLowerCase();
  if (loweredText.includes('once a week') || loweredText.includes('1 day')) {
    return 1;
  } else if (loweredText.includes('twice a week') || loweredText.includes('2 day')) {
    return 2;
  } else if (loweredText.includes('three') || loweredText.includes('3 day')) {
    return 3;
  } else if (loweredText.includes('four') || loweredText.includes('4 day')) {
    return 4;
  } else if (loweredText.includes('five') || loweredText.includes('5 day')) {
    return 5;
  } else if (loweredText.includes('six') || loweredText.includes('6 day')) {
    return 6;
  } else if (loweredText.includes('seven') || loweredText.includes('every day') || loweredText.includes('7 day')) {
    return 7;
  }
  
  // Default to 3 days if we can't determine
  return 3;
}

/**
 * Update any session dates to use the current year
 */
export function updateSessionDatesToCurrentYear(sessions: TrainingSession[], isNewUser: boolean = false): TrainingSession[] {
  const currentYear = new Date().getFullYear();
  const startDate = new Date();
  startDate.setHours(0, 0, 0, 0); // Start of today
  
  // Get the current day of week (0-6, where 0 is Sunday)
  const currentDay = startDate.getDay();
  const daysToMonday = currentDay === 0 ? 6 : currentDay - 1; // Convert to days until Monday
  const startOfCurrentWeek = new Date(startDate);
  startOfCurrentWeek.setDate(startDate.getDate() - daysToMonday);
  startOfCurrentWeek.setHours(0, 0, 0, 0);
  
  return sessions.map((session, index) => {
    try {
      // Parse the date
      const sessionDate = new Date(session.date);
      
      // Check if date is in the past or has an old year
      if (sessionDate.getFullYear() < currentYear || sessionDate < startDate) {
        // For new users in week 1, only include sessions from their signup day onwards
        if (isNewUser && session.week_number === 1) {
          const signupDay = currentDay === 0 ? 7 : currentDay; // Convert to 1-7 format
          if (session.day_of_week < signupDay) {
            return session; // Skip sessions before signup day
          }
        }
        
        // Calculate new date based on week number and day of week
        const newDate = new Date(startOfCurrentWeek);
        newDate.setDate(startOfCurrentWeek.getDate() + (session.week_number - 1) * 7 + (session.day_of_week - 1));
        
        return {
          ...session,
          date: newDate.toISOString().split('T')[0] // YYYY-MM-DD format
        };
      }
      
      return session;
    } catch (err) {
      console.error('Error updating session date:', err);
      return session;
    }
  });
}

/**
 * Get array of days to schedule workouts based on frequency
 */
function getTrainingDays(daysPerWeek: number): number[] {
  // Default to Monday, Wednesday, Friday for 3 days
  const defaultDays = [1, 3, 5]; // 1 = Monday, 3 = Wednesday, 5 = Friday

  if (daysPerWeek <= 0 || daysPerWeek > 7) {
    return defaultDays;
  }

  if (daysPerWeek === 1) {
    return [3]; // Wednesday
  } else if (daysPerWeek === 2) {
    return [2, 5]; // Tuesday, Friday
  } else if (daysPerWeek === 3) {
    return defaultDays;
  } else if (daysPerWeek === 4) {
    return [1, 3, 5, 6]; // Monday, Wednesday, Friday, Saturday
  } else if (daysPerWeek === 5) {
    return [1, 2, 4, 5, 6]; // Monday, Tuesday, Thursday, Friday, Saturday
  } else if (daysPerWeek === 6) {
    return [1, 2, 3, 4, 5, 6]; // Monday through Saturday
  } else {
    return [0, 1, 2, 3, 4, 5, 6]; // Every day
  }
}

/**
 * Generate a basic fallback training plan for initial onboarding
 * Generates from signup date through next Sunday (Week 1) plus one full week (Week 2)
 */
export function generateFallbackPlan(daysPerWeek: number = 3, weeklyVolume: number = 20, units: string = 'km'): TrainingSession[] {
  console.log('Generating fallback training plan with', daysPerWeek, 'days per week and', weeklyVolume, units, 'weekly volume');
  
  // Use current date as starting point
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Start of today
  
  // Default to 3 days if invalid
  if (daysPerWeek < 1 || daysPerWeek > 7) {
    daysPerWeek = 3;
  }
  
  // Calculate average distance per session based on weekly volume
  const avgSessionDistance = weeklyVolume / daysPerWeek || 5; // Default to 5 if calculation fails
  
  // Find the next Sunday for end of Week 1
  const currentDay = today.getDay(); // 0 (Sunday) to 6 (Saturday)
  const daysUntilNextSunday = currentDay === 0 ? 7 : 7 - currentDay;
  const nextSunday = new Date(today);
  nextSunday.setDate(today.getDate() + daysUntilNextSunday);
  
  // Calculate start of Week 2 (Monday after next Sunday)
  const startOfWeekTwo = new Date(nextSunday);
  startOfWeekTwo.setDate(nextSunday.getDate() + 1);
  
  // Calculate end of Week 2 (Sunday)
  const endOfWeekTwo = new Date(startOfWeekTwo);
  endOfWeekTwo.setDate(startOfWeekTwo.getDate() + 6);
  
  // Get array of preferred training days
  const trainingDays = getTrainingDays(daysPerWeek);
  
  const sessions: TrainingSession[] = [];
  
  // Handle Week 1 (partial week)
  const todayDayOfWeek = today.getDay();
  
  // For Week 1, only include sessions on training days that fall between today and next Sunday
  trainingDays.forEach((dayOffset) => {
    // Convert Sunday (0) to 7 for easier comparison
    const normalizedDay = dayOffset === 0 ? 7 : dayOffset;
    const normalizedToday = todayDayOfWeek === 0 ? 7 : todayDayOfWeek;
    
    // Only include if the training day is today or in remaining days of week
    if (normalizedDay >= normalizedToday) {
      const sessionDate = new Date(today);
      sessionDate.setDate(today.getDate() + (normalizedDay - normalizedToday));
      
      // For Week 1, use lighter training load
      sessions.push({
        id: uuidv4(),
        week_number: 1,
        day_of_week: normalizedDay,
        date: sessionDate.toISOString().split('T')[0],
        session_type: 'Easy Run',
        distance: avgSessionDistance * 0.8, // Reduced distance for first week
        time: Math.round(avgSessionDistance * 0.8 * 6), // Approx 6 min per km or 10 min per mile
        notes: `First week easy run of ${(avgSessionDistance * 0.8).toFixed(1)} ${units} to get started. Keep the pace comfortable.`,
        phase: 'Base',
        status: 'not_completed'
      });
    }
  });
  
  // Generate Week 2 (first full week)
    trainingDays.forEach((dayOffset, index) => {
      const sessionDate = new Date(startOfWeekTwo);
    sessionDate.setDate(startOfWeekTwo.getDate() + dayOffset - 1); // -1 because dayOffset is 1-7
      
    // Only include if the date is not past end of Week 2
    if (sessionDate <= endOfWeekTwo) {
      // Determine session type and details based on day
      let sessionType = "Easy Run";
      let distance = avgSessionDistance;
      let time = Math.round(distance * 6); // Approx 6 min per km or 10 min per mile
      let notes = `Easy-paced run of ${distance.toFixed(1)} ${units} to build endurance.`;
      
      if (index === trainingDays.length - 1) {
        // Last workout of week - Long Run
        sessionType = "Long Run";
        distance = avgSessionDistance * 1.3; // Slightly longer run
        time = Math.round(distance * 6.5); // Slightly slower for long run
        notes = `Long run of ${distance.toFixed(1)} ${units}. Focus on consistent pace and proper hydration.`;
      }
      
      sessions.push({
        id: uuidv4(),
        week_number: 2,
        day_of_week: dayOffset === 0 ? 7 : dayOffset,
        date: sessionDate.toISOString().split('T')[0],
        session_type: sessionType,
        distance: parseFloat(distance.toFixed(1)),
        time: time,
        notes: notes,
        phase: 'Base',
        status: 'not_completed'
      });
    }
  });
  
  return sessions;
}

/**
 * Generate a basic fallback plan for weekly refresh
 * Generates exactly 7 days (Monday through Sunday)
 */
export function generateWeeklyFallbackPlan(daysPerWeek: number = 3, weeklyVolume: number = 20, units: string = 'km', phase: string = 'Base'): TrainingSession[] {
  console.log('Generating weekly fallback plan with', daysPerWeek, 'days per week and', weeklyVolume, units, 'weekly volume');
  
  // Default to 3 days if invalid
  if (daysPerWeek < 1 || daysPerWeek > 7) {
    daysPerWeek = 3;
  }
  
  // Calculate average distance per session
  const avgSessionDistance = weeklyVolume / daysPerWeek || 5;
  
  // Get next Monday
  const today = new Date();
  const nextMonday = new Date(today);
  const daysUntilMonday = (8 - today.getDay()) % 7;
  nextMonday.setDate(today.getDate() + daysUntilMonday);
  nextMonday.setHours(0, 0, 0, 0);
  
  // Get training days
  const trainingDays = getTrainingDays(daysPerWeek);
  
  const sessions: TrainingSession[] = [];
  
  // Generate exactly one week
  trainingDays.forEach((dayOffset, index) => {
    const sessionDate = new Date(nextMonday);
    sessionDate.setDate(nextMonday.getDate() + dayOffset - 1); // -1 because dayOffset is 1-7
    
    // Determine session type and details based on day and phase
    let sessionType = "Easy Run";
    let distance = avgSessionDistance;
    let time = Math.round(distance * 6);
    let notes = `Easy-paced run of ${distance.toFixed(1)} ${units} to build endurance.`;
    
    if (phase === 'Build' && index === Math.floor(trainingDays.length / 2)) {
      // Middle workout in Build phase - Quality session
      sessionType = "Interval Training";
      distance = avgSessionDistance * 0.9;
      time = Math.round(distance * 5);
      notes = `Interval session: ${Math.floor(distance / 0.4)}x400m with 2 min rest. Total: ${distance.toFixed(1)} ${units}.`;
    } else if (index === trainingDays.length - 1) {
      // Last workout - Long Run
      sessionType = "Long Run";
      distance = avgSessionDistance * 1.3;
      time = Math.round(distance * 6.5);
      notes = `Long run of ${distance.toFixed(1)} ${units}. Keep it steady and comfortable.`;
    }
    
    sessions.push({
      id: uuidv4(),
      week_number: 1, // Always week 1 for weekly plans
      day_of_week: dayOffset === 0 ? 7 : dayOffset,
      date: sessionDate.toISOString().split('T')[0],
      session_type: sessionType,
      distance: parseFloat(distance.toFixed(1)),
      time: time,
      notes: notes,
      phase: phase,
      status: 'not_completed'
    });
  });
  
  return sessions;
}

export function updateSessionDates(sessions: TrainingSession[], isNewUser: boolean = false): TrainingSession[] {
  // Get the start of the current week (Monday)
  const now = new Date();
  const currentDay = now.getDay(); // 0 (Sunday) to 6 (Saturday)
  const daysToMonday = currentDay === 0 ? 6 : currentDay - 1; // Convert to days until Monday
  const startOfCurrentWeek = new Date(now);
  startOfCurrentWeek.setDate(now.getDate() - daysToMonday);
  startOfCurrentWeek.setHours(0, 0, 0, 0);

  // Group sessions by week and sort them
  const sessionsByWeek = sessions.reduce((acc, session) => {
    if (!acc[session.week_number]) {
      acc[session.week_number] = [];
    }
    acc[session.week_number].push(session);
    return acc;
  }, {} as Record<number, TrainingSession[]>);

  // Sort weeks and sessions within each week
  const sortedWeeks = Object.keys(sessionsByWeek)
    .map(Number)
    .sort((a, b) => a - b);
  
  for (const week of sortedWeeks) {
    sessionsByWeek[week].sort((a, b) => a.day_of_week - b.day_of_week);
  }

  // Update session dates
  const updatedSessions: TrainingSession[] = [];
  for (const week of sortedWeeks) {
    const weekSessions = sessionsByWeek[week];
    
    // For new users in week 1, only include sessions from their signup day onwards
    if (isNewUser && week === 1) {
      const signupDay = currentDay === 0 ? 7 : currentDay; // Convert to 1-7 format
      for (const session of weekSessions) {
        // Skip sessions before the signup day
        if (session.day_of_week < signupDay) {
          continue;
        }
        
        const sessionDate = new Date(startOfCurrentWeek);
        sessionDate.setDate(startOfCurrentWeek.getDate() + (session.day_of_week - 1));
        
        updatedSessions.push({
          ...session,
          id: session.id || uuidv4(),
          date: sessionDate.toISOString(),
          day_of_week: session.day_of_week,
          week_number: session.week_number,
          status: session.status || 'not_completed'
        });
      }
    } else {
      // For all other cases, include all sessions starting from Monday
      for (const session of weekSessions) {
        const sessionDate = new Date(startOfCurrentWeek);
        sessionDate.setDate(startOfCurrentWeek.getDate() + (week - 1) * 7 + (session.day_of_week - 1));
        
        updatedSessions.push({
          ...session,
          id: session.id || uuidv4(),
          date: sessionDate.toISOString(),
          day_of_week: session.day_of_week,
          week_number: session.week_number,
          status: session.status || 'not_completed'
        });
      }
    }
  }

  return updatedSessions;
}

export const createTrainingSession = (
  weekNumber: number,
  date: string,
  sessionType: string,
  distance: number,
  time: number,
  notes: string
): TrainingSession => {
  const dayOfWeek = new Date(date).getDay() || 7; // Convert 0 (Sunday) to 7
  return {
    id: uuidv4(), // Generate a unique ID
    week_number: weekNumber,
    date,
    session_type: sessionType,
    distance,
    time,
    notes,
    day_of_week: dayOfWeek,
    status: 'not_completed'
  };
};

/**
 * Parse a text-based training plan into structured TrainingSession objects
 * @param planText The text-based training plan
 * @param defaultUnits Default units (km or miles) to use if not specified
 * @returns Array of TrainingSession objects
 */
export function parseTextPlanToSessions(planText: string, defaultUnits: string = 'km'): TrainingSession[] {
  const sessions: TrainingSession[] = [];
  const lines = planText.split('\n').map(line => line.trim());
  
  // Extract week number 
  let weekNumber = 1;
  const weekNumberMatch = planText.match(/Week (?:Number)?\s*:?\s*\[?(\d+)\]?|WEEK\s+(\d+)/i);
  if (weekNumberMatch) {
    weekNumber = parseInt(weekNumberMatch[1] || weekNumberMatch[2], 10);
  }
  
  // Extract phase
  let phase = 'Base';
  const phaseMatch = planText.match(/Phase\s*:?\s*\[?([a-zA-Z\s]+)\]?/i);
  if (phaseMatch) {
    phase = phaseMatch[1].trim();
  }
  
  // First try to parse markdown table format
  if (planText.includes('|')) {
    console.log('Detected table format in training plan');
    
    let tableStarted = false;
    let isHeaderRow = false;
    let isDelimiterRow = false;
    let columnIndices: {[key: string]: number} = {};
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines
      if (!line) continue;
      
      // Check if this is a table row
      if (line.startsWith('|') && line.endsWith('|')) {
        // Split the row into columns
        const columns = line.split('|')
          .map(col => col.trim())
          .filter((col, index) => index > 0 && index < line.split('|').length - 1);
        
        // If this is the first row with pipes, assume it's the header
        if (!tableStarted) {
          tableStarted = true;
          isHeaderRow = true;
          
          // Map column names to their indices
          columns.forEach((col, idx) => {
            const colName = col.toLowerCase();
            if (colName.includes('date')) columnIndices['date'] = idx;
            else if (colName.includes('day')) columnIndices['day'] = idx;
            else if (colName.includes('type')) columnIndices['type'] = idx;
            else if (colName.includes('distance')) columnIndices['distance'] = idx;
            else if (colName.includes('time')) columnIndices['time'] = idx;
            else if (colName.includes('notes')) columnIndices['notes'] = idx;
          });
          
          continue;
        }
        
        // Skip the delimiter row (the one with dashes)
        if (isHeaderRow && line.includes('---')) {
          isHeaderRow = false;
          isDelimiterRow = true;
          continue;
        }
        
        // Skip the delimiter row
        if (isDelimiterRow) {
          isDelimiterRow = false;
          continue;
        }
        
        // This is a data row, extract the session details
        let sessionDate = '';
        let sessionDay = '';
        let sessionType = '';
        let distance = 0;
        let time = 0;
        let notes = '';
        
        // Extract values based on column mappings
        if ('date' in columnIndices) {
          sessionDate = columns[columnIndices['date']];
        }
        
        if ('day' in columnIndices) {
          sessionDay = columns[columnIndices['day']];
        }
        
        if ('type' in columnIndices) {
          sessionType = columns[columnIndices['type']];
        }
        
        if ('distance' in columnIndices && columns[columnIndices['distance']]) {
          const distanceText = columns[columnIndices['distance']];
          if (distanceText && distanceText !== '-') {
            distance = parseDistance(distanceText, defaultUnits);
          }
        }
        
        if ('time' in columnIndices && columns[columnIndices['time']]) {
          const timeText = columns[columnIndices['time']];
          if (timeText && timeText !== '-') {
            time = parseTime(timeText);
          }
        }
        
        if ('notes' in columnIndices) {
          notes = columns[columnIndices['notes']];
        }
        
        // Skip rest days or empty rows
        if (!sessionType || sessionType.toLowerCase().includes('rest')) {
          continue;
        }
        
        // Determine day of week from day name or date
        let dayOfWeek = 0;
        if (sessionDay) {
          // Try to parse day name
          const dayNames = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
          for (let d = 0; d < dayNames.length; d++) {
            if (sessionDay.toLowerCase().includes(dayNames[d])) {
              dayOfWeek = d + 1;
              break;
            }
          }
        }
        
        // If we couldn't get day from name, try from date
        if (dayOfWeek === 0 && sessionDate) {
          try {
            const dateObj = new Date(sessionDate);
            if (!isNaN(dateObj.getTime())) {
              // getDay() returns 0 for Sunday, but we want 1=Monday, 7=Sunday
              dayOfWeek = dateObj.getDay() || 7; 
              sessionDate = dateObj.toISOString().split('T')[0]; // Format as YYYY-MM-DD
            }
          } catch (e) {
            console.log('Error parsing date:', e);
          }
        }
        
        // Only add valid sessions
        if (sessionType && (distance > 0 || sessionType.toLowerCase().includes('rest'))) {
          sessions.push({
            id: uuidv4(),
            week_number: weekNumber,
            day_of_week: dayOfWeek,
            date: sessionDate || '',
            session_type: sessionType,
            distance: distance,
            time: time,
            notes: notes || 'No specific notes.',
            phase: phase,
            status: 'not_completed'
          });
        }
      }
    }
    
    // If we found any sessions in table format, return them
    if (sessions.length > 0) {
      console.log(`Successfully parsed ${sessions.length} sessions from table format`);
      return sessions;
    }
  }
  
  // If we get here, no table format was found or it couldn't be parsed
  // Fall back to the original parsing logic for text format
  console.log('Falling back to text format parsing');
  
  // Initialize variables to track the current day being parsed
  let currentDay: string | null = null;
  let dayOfWeek = 0; // Will be 1-7
  let sessionType = '';
  let distance = 0;
  let time = 0;
  let notes = '';
  let date = '';
  
  // Helper to reset variables for each new day
  const resetDayVariables = () => {
    sessionType = '';
    distance = 0;
    time = 0;
    notes = '';
    date = '';
  };
  
  // Helper to add the current session if valid
  const addCurrentSession = () => {
    if (currentDay && sessionType) {
      // Convert day name to day of week (1-7, Monday to Sunday)
      switch (currentDay.toLowerCase()) {
        case 'monday': dayOfWeek = 1; break;
        case 'tuesday': dayOfWeek = 2; break;
        case 'wednesday': dayOfWeek = 3; break;
        case 'thursday': dayOfWeek = 4; break;
        case 'friday': dayOfWeek = 5; break;
        case 'saturday': dayOfWeek = 6; break;
        case 'sunday': dayOfWeek = 7; break;
        default: dayOfWeek = 0; // Unknown day
      }
      
      if (dayOfWeek > 0) {
        sessions.push({
          id: uuidv4(),
          week_number: weekNumber,
          day_of_week: dayOfWeek,
          date: date || '', // Will be filled in later if empty
          session_type: sessionType,
          distance: distance,
          time: time,
          notes: notes,
          phase: phase,
          status: 'not_completed'
        });
      }
      resetDayVariables();
    }
  };
  
  // Process each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if this line is a day header (various formats)
    const dayMatch = line.match(/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday):|^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),/i);
    if (dayMatch) {
      // If we were already parsing a day, add it to the sessions
      addCurrentSession();
      
      // Start parsing the new day
      currentDay = dayMatch[1] || dayMatch[2];
      continue;
    }
    
    // Skip lines that don't have useful information
    if (!currentDay || (!line.includes('-') && !line.includes(':'))) continue;
    
    // Parse the line based on the type of information
    if (line.toLowerCase().includes('type:') || line.toLowerCase().includes('- type')) {
      sessionType = extractValue(line);
    } else if (line.toLowerCase().includes('distance:') || line.toLowerCase().includes('- distance')) {
      // Extract numeric distance and handle units
      const distanceText = extractValue(line);
      distance = parseDistance(distanceText, defaultUnits);
    } else if (line.toLowerCase().includes('time:') || line.toLowerCase().includes('- time')) {
      // Extract numeric time in minutes
      const timeText = extractValue(line);
      time = parseTime(timeText);
    } else if (line.toLowerCase().includes('notes:') || line.toLowerCase().includes('- notes')) {
      notes = extractValue(line);
    } else if (line.toLowerCase().includes('date:') || line.toLowerCase().includes('- date')) {
      date = extractValue(line);
    }
  }
  
  // Add the final session if we were parsing one
  addCurrentSession();
  
  // Try additional parsing formats if no sessions were found
  if (sessions.length === 0) {
    console.log('No sessions found using standard formats, trying alternative parsing');
    
    // Look for patterns like "Wednesday, 2025-05-07" or "2025-05-07 (Wednesday)"
    const dateRegex = /(\d{4}-\d{2}-\d{2}).*?(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)|(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday).*?(\d{4}-\d{2}-\d{2})/i;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      // Try to find date and day
      const dateMatch = line.match(dateRegex);
      if (dateMatch) {
        const sessionDate = dateMatch[1] || dateMatch[3] || '';
        const dayMatch = line.match(/(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)/i);
        const sessionDay = dayMatch ? dayMatch[0] : '';
        
        if (!sessionDay && !sessionDate) continue;
        
        // Look for session details in the following lines
        let sessionType = '';
        let distance = 0;
        let time = 0;
        let notes = '';
        
        // Check the next few lines for session details
        for (let j = 1; j <= 5 && i + j < lines.length; j++) {
          const detailLine = lines[i + j].trim();
          
          if (detailLine.toLowerCase().includes('type:') || detailLine.toLowerCase().includes('- type')) {
            sessionType = extractValue(detailLine);
          } else if (detailLine.toLowerCase().includes('distance:') || detailLine.toLowerCase().includes('- distance')) {
            const distanceText = extractValue(detailLine);
            distance = parseDistance(distanceText, defaultUnits);
          } else if (detailLine.toLowerCase().includes('time:') || detailLine.toLowerCase().includes('- time')) {
            const timeText = extractValue(detailLine);
            time = parseTime(timeText);
          } else if (detailLine.toLowerCase().includes('notes:') || detailLine.toLowerCase().includes('- notes')) {
            notes = extractValue(detailLine);
          }
        }
        
        // Only add valid sessions (with at least a type and distance)
        if (sessionType && (distance > 0 || sessionType.toLowerCase().includes('rest'))) {
          // Convert day name to day of week (1-7, Monday to Sunday)
          let dayOfWeek = 0;
          if (sessionDay) {
            const dayLower = sessionDay.toLowerCase();
            if (dayLower.includes('monday')) dayOfWeek = 1;
            else if (dayLower.includes('tuesday')) dayOfWeek = 2;
            else if (dayLower.includes('wednesday')) dayOfWeek = 3;
            else if (dayLower.includes('thursday')) dayOfWeek = 4;
            else if (dayLower.includes('friday')) dayOfWeek = 5;
            else if (dayLower.includes('saturday')) dayOfWeek = 6;
            else if (dayLower.includes('sunday')) dayOfWeek = 7;
          }
          
          if (dayOfWeek > 0 && !sessionType.toLowerCase().includes('rest')) {
            sessions.push({
              id: uuidv4(),
              week_number: weekNumber,
              day_of_week: dayOfWeek,
              date: sessionDate || '',
              session_type: sessionType,
              distance: distance,
              time: time,
              notes: notes || 'No specific notes.',
              phase: phase,
              status: 'not_completed'
            });
          }
        }
      }
    }
  }
  
  console.log(`Total sessions parsed: ${sessions.length}`);
  return sessions;
}

/**
 * Extract value from a line in the format "- Label: [Value]" or "- Label: Value"
 */
function extractValue(line: string): string {
  // Try to match [Value] format first
  const bracketMatch = line.match(/\[(.*?)\]/);
  if (bracketMatch) return bracketMatch[1].trim();
  
  // Fall back to matching after colon
  const colonMatch = line.match(/:\s*(.+)$/);
  if (colonMatch) return colonMatch[1].trim();
  
  return '';
}

/**
 * Parse distance text to number, handling various formats
 */
function parseDistance(text: string, defaultUnits: string): number {
  // Remove any non-numeric characters except decimal point and units
  const cleanText = text.toLowerCase().replace(/[^\d.\s\w]/g, '');
  
  // Extract numeric value
  const numMatch = cleanText.match(/(\d+\.?\d*)/);
  if (!numMatch) return 0;
  
  const value = parseFloat(numMatch[1]);
  
  // Check if there's a unit conversion needed
  if ((cleanText.includes('mile') || cleanText.includes('mi')) && defaultUnits === 'km') {
    return Math.round(value * 1.609344 * 10) / 10; // Convert miles to km with 1 decimal precision
  } else if ((cleanText.includes('km') || cleanText.includes('kilometer')) && defaultUnits === 'miles') {
    return Math.round(value / 1.609344 * 10) / 10; // Convert km to miles with 1 decimal precision
  }
  
  return value;
}

/**
 * Parse time text to number of minutes
 */
function parseTime(text: string): number {
  // Handle formats like "40 minutes", "1 hour 30 minutes", "1:30", "1h30m"
  
  // Check for hours and minutes format (e.g., "1 hour 30 minutes" or "1h30m")
  const hourMinRegex = /(\d+)\s*(?:h|hour|hours)?\s*(?:and)?\s*(\d+)\s*(?:m|min|minutes)?/i;
  const hourMinMatch = text.match(hourMinRegex);
  if (hourMinMatch) {
    const hours = parseInt(hourMinMatch[1], 10) || 0;
    const mins = parseInt(hourMinMatch[2], 10) || 0;
    return hours * 60 + mins;
  }
  
  // Check for time format (e.g., "1:30")
  const timeFormatMatch = text.match(/(\d+):(\d+)/);
  if (timeFormatMatch) {
    const hours = parseInt(timeFormatMatch[1], 10) || 0;
    const mins = parseInt(timeFormatMatch[2], 10) || 0;
    return hours * 60 + mins;
  }
  
  // Check for just minutes (e.g., "45 minutes" or "45m" or "45")
  const minOnlyRegex = /(\d+)\s*(?:m|min|minutes)?/i;
  const minMatch = text.match(minOnlyRegex);
  if (minMatch) {
    return parseInt(minMatch[1], 10) || 0;
  }
  
  // Handle "about X minutes" or "~X minutes"
  const approxMatch = text.match(/(?:about|~)\s*(\d+)/i);
  if (approxMatch) {
    return parseInt(approxMatch[1], 10) || 0;
  }
  
  return 0;
} 